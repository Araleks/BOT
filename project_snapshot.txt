PROJECT SNAPSHOT
Generated at: 2026-02-01 15:38:48

Included files:
  - export_project_snapshot.py
  - falling_star_daemon.py
  - handlers\__init__.py
  - handlers\log_handler.py
  - handlers\paper_handler.py
  - handlers\paper_trading.py
  - handlers\telegram_handler.py
  - notifier.py
  - setup_manager.py
  - setups\__init__.py
  - setups\falling_star.py
  - setups\hammer.py
  - setups\max_volume_zone.py
  - setups\rsi_zone.py
  - signal_formatter.py
  - signal_router.py
  - test_save.py
  - test_setup_manager.py
  - utils\__init__.py
  - utils\timeframes.py

================================================================================

================================================================================
FILE: export_project_snapshot.py
PATH: export_project_snapshot.py
================================================================================

import os
from datetime import datetime

# === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ===

INCLUDE_DIRS = [
    "setups",
    "utils",
    "handlers",
]

ALLOWED_EXTENSIONS = {".py", ".env"}

EXCLUDE_DIRS = {".venv", "__pycache__", ".git"}

OUTPUT_FILENAME = "project_snapshot.txt"


def should_include_file(path: str) -> bool:
    _, ext = os.path.splitext(path)
    return ext in ALLOWED_EXTENSIONS


def walk_and_collect(base_dir: str) -> list[tuple[str, str]]:
    collected = []

    for root, dirs, files in os.walk(base_dir):
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]

        for fname in files:
            abs_path = os.path.join(root, fname)
            rel_path = os.path.relpath(abs_path, start=".")

            if should_include_file(abs_path):
                collected.append((abs_path, rel_path))

    return collected


def read_file_safely(path: str) -> str:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read()
    except UnicodeDecodeError:
        try:
            with open(path, "r", encoding="cp1251") as f:
                return f.read()
        except Exception as e:
            return f"<<–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ (–∫–æ–¥–∏—Ä–æ–≤–∫–∞): {e}>>"
    except Exception as e:
        return f"<<–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {e}>>"


def main():
    all_files = []

    # 0. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ .py –∏ .env —Ñ–∞–π–ª—ã –∏–∑ –∫–æ—Ä–Ω—è
    for fname in os.listdir("."):
        if os.path.isfile(fname) and should_include_file(fname):
            abs_path = os.path.abspath(fname)
            rel_path = fname
            if (abs_path, rel_path) not in all_files:
                all_files.append((abs_path, rel_path))

    # 1. –û–±—Ö–æ–¥–∏–º —É–∫–∞–∑–∞–Ω–Ω—ã–µ –ø–∞–ø–∫–∏
    for d in INCLUDE_DIRS:
        if not os.path.isdir(d):
            continue
        collected = walk_and_collect(d)
        for abs_path, rel_path in collected:
            if (abs_path, rel_path) not in all_files:
                all_files.append((abs_path, rel_path))

    # 2. –°–æ—Ä—Ç–∏—Ä—É–µ–º
    all_files.sort(key=lambda x: x[1])

    # 3. –ü–∏—à–µ–º –≤ —Ñ–∞–π–ª
    now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    header = [
        "PROJECT SNAPSHOT",
        f"Generated at: {now_str}",
        "",
        "Included files:",
    ]
    for _, rel_path in all_files:
        header.append(f"  - {rel_path}")
    header.append("\n" + "=" * 80 + "\n")

    with open(OUTPUT_FILENAME, "w", encoding="utf-8") as out:
        out.write("\n".join(header))

        for abs_path, rel_path in all_files:
            out.write(f"\n{'=' * 80}\n")
            out.write(f"FILE: {os.path.basename(rel_path)}\n")
            out.write(f"PATH: {rel_path}\n")
            out.write(f"{'=' * 80}\n\n")

            content = read_file_safely(abs_path)
            out.write(content)
            out.write("\n\n")

    print(f"‚úÖ –°–Ω–∏–º–æ–∫ –ø—Ä–æ–µ–∫—Ç–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ —Ñ–∞–π–ª: {OUTPUT_FILENAME}")
    print(f"–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: {len(all_files)}")


if __name__ == "__main__":
    main()



================================================================================
FILE: falling_star_daemon.py
PATH: falling_star_daemon.py
================================================================================

# falling_star_daemon.py

import os
import time
from dataclasses import dataclass
from collections import deque
from typing import Dict, Deque, Tuple, List

import ccxt
from dotenv import load_dotenv

from utils.timeframes import tf_seconds

from setup_manager import SetupManager
from setups import FallingStarSetup, HammerSetup, MaxVolumeZoneSetup, RSIZoneSetup
from models import Candle

from signal_router import SignalRouter
from handlers.telegram_handler import make_telegram_handler
from handlers.log_handler import log_handler
from handlers.paper_trading import PaperTradingEngine, make_paper_trading_handler


@dataclass
class Config:
    exchange_id: str
    symbols: list[str]
    timeframes: list[str]
    tz: str
    tg_token: str
    tg_chat_id: str
    poll_sec: float = 5.0


def load_config() -> Config:
    load_dotenv()
    exchange_id = (os.getenv("EXCHANGE_ID") or "binance").strip()
    symbols = [s.strip() for s in (os.getenv("SYMBOLS") or "BTC/USDT").split(",") if s.strip()]
    timeframes = [t.strip() for t in (os.getenv("TIMEFRAMES") or "5m").split(",") if t.strip()]
    tz = (os.getenv("TZ") or "Europe/Helsinki").strip()
    tg_token = (os.getenv("TELEGRAM_BOT_TOKEN") or "").strip()
    tg_chat_id = (os.getenv("TELEGRAM_CHAT_ID") or "").strip()
    return Config(exchange_id, symbols, timeframes, tz, tg_token, tg_chat_id)


def make_exchange(exchange_id: str) -> ccxt.Exchange:
    exchange_class = getattr(ccxt, exchange_id)
    exchange = exchange_class(
        {
            "enableRateLimit": True,
            "options": {"defaultType": "spot"},
        }
    )
    exchange.load_markets()
    return exchange

Store = Dict[Tuple[str, str], Deque[Tuple[int, float, float, float, float]]]

def ts_close_from_open(t_open_ms: int, timeframe_sec: int) -> int:
    return t_open_ms + timeframe_sec * 1000

def main():
    cfg = load_config()

    exchange = make_exchange(cfg.exchange_id)
    # —Å–æ–∑–¥–∞—ë–º –¥–≤–∏–∂–æ–∫ –±—É–º–∞–∂–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–ª–∏
    paper_engine = PaperTradingEngine(exchange)

    router = SignalRouter(
        handlers=[
            make_telegram_handler(cfg.tg_token, cfg.tg_chat_id, cfg.tz), 
            log_handler, 
            make_paper_trading_handler(paper_engine),
        ]
    )
    
    setup_manager = SetupManager(
        setups=[
            FallingStarSetup(),
            HammerSetup(),
            MaxVolumeZoneSetup(exchange, cfg),
            RSIZoneSetup(exchange, cfg),
        ]
    )

    last_seen_close: Dict[Tuple[str, str], int] = {}
    store: Store = {}

    for symbol in cfg.symbols:
        for timeframe in cfg.timeframes:
            key = (symbol, timeframe)
            try:
                limit = 10
                raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
                if not raw or len(raw) < 2:
                    print(f"‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö: {symbol} {timeframe}")
                    continue

                timeframe_sec = tf_seconds(exchange, timeframe)

                closed_rows = raw[:-1]
                deque5: Deque[Candle] = deque(maxlen=5)

                for row in closed_rows[-5:]:
                    t_open_ms, o, h, l, c, *_ = row
                    t_close_ms = ts_close_from_open(int(t_open_ms), timeframe_sec)
                    deque5.append(
                        (
                            t_close_ms,
                            float(o),
                            float(h),
                            float(l),
                            float(c),
                        )
                    )

                store[key] = deque5

                if deque5:
                    last_seen_close[key] = deque5[-1][0]

            except Exception as e:
                print(f"‚ùå –ü—Ä–µ–¥–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ {symbol} {timeframe}: {e}")

            time.sleep(0.15)

    print("üü¢ –°—Ç–∞—Ä—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞‚Ä¶")

    while True:
        for symbol in cfg.symbols:
            for timeframe in cfg.timeframes:
                key = (symbol, timeframe)
                try:
                    limit = 10
                    raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
                    if not raw or len(raw) < 2:
                        continue

                    timeframe_sec = tf_seconds(exchange, timeframe)

                    closed_records: List[Tuple[int, float, float, float, float]] = []
                    for row in raw[:-1]: 
                        t_open_ms, o, h, l, c, *_ = row 
                        t_close_ms = ts_close_from_open(int(t_open_ms), timeframe_sec) 
                        closed_records.append( ( 
                            t_close_ms, 
                            float(o), 
                            float(h), 
                            float(l), 
                            float(c), 
                            ) 
                        )
                    
                    closed_records.sort(key=lambda x: x[0])

                    last_close_ts = last_seen_close.get(key, 0)

                    for (t_close_ms, o, h, l, c) in closed_records:
                        if t_close_ms <= last_close_ts:
                            continue

                        candle = Candle(
                            symbol=symbol,
                            timeframe=timeframe,
                            t_close_ms=t_close_ms,
                            o=o,
                            h=h,
                            l=l,
                            c=c,
                        )

                        # 1. –°–Ω–∞—á–∞–ª–∞ –¥–∞—ë–º —Å–≤–µ—á—É PaperTradingEngine (–¥–ª—è –æ—Ç—Ä–∞–±–æ—Ç–∫–∏ SL/TP –ø–æ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç—ã–º –ø–æ–∑–∏—Ü–∏—è–º) 
                        paper_engine.on_candle(candle)
                        
                        # 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã
                        signals = setup_manager.process_candle(candle)

                        # 3. –û–±–æ–≥–∞—â–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –¥–∞–Ω–Ω—ã–º–∏ —Å–≤–µ—á–∏ (–¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –Ω–æ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏–π)
                        for sig in signals: 
                            sig.extra.setdefault("candle", { 
                                "o": candle.o, 
                                "h": candle.h, 
                                "l": candle.l, 
                                "c": candle.c, 
                            }) 
                            router.route(sig)

                        deque_for_key = store.get(key)
                        if deque_for_key is None:
                            deque_for_key = deque(maxlen=5)
                            store[key] = deque_for_key
                        deque_for_key.append((t_close_ms, o, h, l, c))

                        last_seen_close[key] = t_close_ms
                        last_close_ts = t_close_ms

                    if closed_records:
                        last5 = closed_records[-5:]
                        deque_for_key = deque(last5, maxlen=5)
                        store[key] = deque_for_key

                except ccxt.RateLimitExceeded as e:
                    print(f"‚è≥ Rate limit {symbol} {timeframe}: {e}; –ø–∞—É–∑–∞ 2—Å")
                    time.sleep(2)
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ {symbol} {timeframe}: {e}")

                time.sleep(0.15)

        time.sleep(cfg.poll_sec)


if __name__ == "__main__":
    main()



================================================================================
FILE: __init__.py
PATH: handlers\__init__.py
================================================================================

# handlers/__init__.py
# –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç—ã–º



================================================================================
FILE: log_handler.py
PATH: handlers\log_handler.py
================================================================================

# handlers/log_handler.py
from models import Signal


def log_handler(signal: Signal):
    print(
        f"LOG: {signal.symbol} {signal.timeframe} {signal.setup} "
        f"{signal.direction} @ {signal.t_close_ms}"
    )



================================================================================
FILE: paper_handler.py
PATH: handlers\paper_handler.py
================================================================================

# handlers/paper_handler.py
from models import Signal


def paper_handler(signal: Signal):
    print(f"PAPER: –æ–±—Ä–∞–±–æ—Ç–∞–Ω —Å–∏–≥–Ω–∞–ª {signal.setup} {signal.symbol}")



================================================================================
FILE: paper_trading.py
PATH: handlers\paper_trading.py
================================================================================

# handlers/paper_trading.py

from __future__ import annotations

from dataclasses import dataclass, field, asdict
from typing import List, Optional

from models import Signal, Candle
from web.backend.app.models import TradePart, CompletedTrade

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
from analytics.stats import print_stats_for_trades
from analytics.csv_export import export_trades_to_csv
from analytics.equity import plot_equity_curve_for_trades


@dataclass
class Position:
    """
    –û—Ç–∫—Ä—ã—Ç–∞—è –±—É–º–∞–∂–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è.
    """
    id: int
    symbol: str
    timeframe: str
    direction: str  # 'long' –∏–ª–∏ 'short'
    setup: str
    opened_at_ms: int
    entry_price: float
    size_usdt: float
    qty: float

    sl: float
    tp1: float
    tp2: float

    tp1_hit: bool = False
    closed: bool = False
    closed_at_ms: Optional[int] = None
    parts: List[TradePart] = field(default_factory=list)

    def remaining_qty(self) -> float:
        used = sum(p.qty for p in self.parts)
        return self.qty - used

    def remaining_size_usdt(self) -> float:
        if self.qty == 0:
            return 0.0
        # –ü—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É
        return self.size_usdt * (self.remaining_qty() / self.qty)


class PaperTradingEngine:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –¥–≤–∏–∂–æ–∫ –±—É–º–∞–∂–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–ª–∏.
    - –û—Ç–∫—Ä—ã–≤–∞–µ—Ç —Å–¥–µ–ª–∫–∏ –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º (–∫—Ä–æ–º–µ RSI).
    - –û—Ç—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç SL/TP –ø–æ –Ω–æ–≤—ã–º —Å–≤–µ—á–∞–º.
    - –í–µ–¥—ë—Ç –∏—Å—Ç–æ—Ä–∏—é —Å–¥–µ–ª–æ–∫.
    """

    def __init__(
        self,
        exchange,
        initial_balance_usdt: float = 100_000.0,
        risk_per_trade_usdt: float = 100.0,
        sl_offset_pct: float = 0.001,  # 0.1% –æ—Ç —Ü–µ–Ω—ã —Å–≤–µ—á–∏
    ):
        self.exchange = exchange
        self.initial_balance_usdt = initial_balance_usdt
        self.risk_per_trade_usdt = risk_per_trade_usdt
        self.sl_offset_pct = sl_offset_pct

        self._next_position_id = 1
        self.open_positions: List[Position] = []
        self.completed_trades: List[CompletedTrade] = []

    # ---------- –ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã ----------

    def on_signal(self, signal: Signal):
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞: –æ—Ç–∫—Ä—ã—Ç–∏–µ –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏.
        """
        # –ù–µ —Ç–æ—Ä–≥—É–µ–º RSI
        if signal.setup == "RSI":
            return

        # –ù–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É—é—Ç —Ç–æ–ª—å–∫–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
        if signal.direction not in ("bull", "bear"):
            return

        candle_data = signal.extra.get("candle")
        if not candle_data:
            # –ë–µ–∑ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–∏ –Ω–µ –º–æ–∂–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø–æ—Å—á–∏—Ç–∞—Ç—å SL/TP
            print(f"‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–∏ –≤ signal.extra['candle'] –¥–ª—è {signal.symbol} {signal.timeframe}")
            return

        o = float(candle_data["o"])
        h = float(candle_data["h"])
        l = float(candle_data["l"])
        c = float(candle_data["c"])

        # 1. –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É –≤—Ö–æ–¥–∞ –ø–æ —Ä—ã–Ω–∫—É
        entry_price = self._get_entry_price(signal.symbol, signal.direction)
        if entry_price is None:
            print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É –≤—Ö–æ–¥–∞ –¥–ª—è {signal.symbol}")
            return

        # 2. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º SL –æ—Ç —Å–≤–µ—á–∏ —Å–∏–≥–Ω–∞–ª–∞
        sl = self._calc_stop_loss(signal.direction, h, l)

        # 3. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º TP1 –∏ TP2
        tp1, tp2 = self._calc_take_profits(signal.direction, entry_price, sl)

        # 4. –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏: —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ 100 USDT
        size_usdt = self.risk_per_trade_usdt
        qty = self._calc_qty(size_usdt, entry_price, signal.direction)

        # 5. –°–æ–∑–¥–∞—ë–º –ø–æ–∑–∏—Ü–∏—é
        pos = Position(
            id=self._next_position_id,
            symbol=signal.symbol,
            timeframe=signal.timeframe,
            direction="long" if signal.direction == "bull" else "short",
            setup=signal.setup,
            opened_at_ms=signal.t_close_ms,
            entry_price=entry_price,
            size_usdt=size_usdt,
            qty=qty,
            sl=sl,
            tp1=tp1,
            tp2=tp2,
        )
        self._next_position_id += 1

        self.open_positions.append(pos)

        print(
            f"PAPER OPEN #{pos.id}: {pos.symbol} {pos.timeframe} {pos.direction} "
            f"entry={pos.entry_price:.4f} sl={pos.sl:.4f} tp1={pos.tp1:.4f} tp2={pos.tp2:.4f} "
            f"size={pos.size_usdt}USDT qty={pos.qty:.6f}"
        )

    def on_candle(self, candle: Candle):
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–π —Å–≤–µ—á–∏: –ø—Ä–æ–≤–µ—Ä–∫–∞ SL/TP –¥–ª—è –≤—Å–µ—Ö –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π –ø–æ —ç—Ç–æ–º—É —Å–∏–º–≤–æ–ª—É.
        –í–∞–∂–Ω–æ: –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –∫–∞–∂–¥–æ–π –∑–∞–∫—Ä—ã—Ç–æ–π —Å–≤–µ—á–µ (–∫–∞–∫ –∏ —Å–µ—Ç–∞–ø—ã).
        """
        if not self.open_positions:
            return

        symbol = candle.symbol
        high = candle.h
        low = candle.l
        t_close_ms = candle.t_close_ms

        # –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–æ–ø–∏–∏ —Å–ø–∏—Å–∫–∞, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª
        for pos in list(self.open_positions):
            if pos.symbol != symbol:
                continue
            if pos.closed:
                continue

            self._process_position_on_candle(pos, high, low, t_close_ms)

        # –£–¥–∞–ª—è–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ —Å–ø–∏—Å–∫–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö
        self.open_positions = [p for p in self.open_positions if not p.closed]

    # ---------- –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –ª–æ–≥–∏–∫–∞ ----------

    def _get_entry_price(self, symbol: str, direction: str) -> Optional[float]:
        """
        –ò–º–∏—Ç–∞—Ü–∏—è –≤—Ö–æ–¥–∞ –ø–æ —Ä—ã–Ω–∫—É: –±–µ—Ä—ë–º bid/ask –∏–∑ —Ç–∏–∫–µ—Ä–∞.
        """
        try:
            ticker = self.exchange.fetch_ticker(symbol)
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–∏–∫–µ—Ä–∞ –¥–ª—è {symbol}: {e}")
            return None

        bid = ticker.get("bid")
        ask = ticker.get("ask")
        last = ticker.get("last")

        if direction == "bull":
            # –ü–æ–∫—É–ø–∫–∞ –ø–æ —Ä—ã–Ω–∫—É ‚Äî –±–ª–∏–∂–µ –∫ ask
            return ask or last or bid
        else:
            # –ü—Ä–æ–¥–∞–∂–∞ –ø–æ —Ä—ã–Ω–∫—É ‚Äî –±–ª–∏–∂–µ –∫ bid
            return bid or last or ask

    def _calc_stop_loss(self, direction: str, h: float, l: float) -> float:
        """
        SL –æ—Ç —Å–≤–µ—á–∏ —Å–∏–≥–Ω–∞–ª–∞:
        - long: —á—É—Ç—å –Ω–∏–∂–µ low
        - short: —á—É—Ç—å –≤—ã—à–µ high
        """
        if direction == "bull":
            offset = l * self.sl_offset_pct
            return l - offset
        else:
            offset = h * self.sl_offset_pct
            return h + offset

    def _calc_take_profits(self, direction: str, entry_price: float, sl: float) -> tuple[float, float]:
        """
        TP1 = 1.5R, TP2 = 3R, –≥–¥–µ R = |entry - SL|.
        """
        risk = abs(entry_price - sl)
        if direction == "bull":
            tp1 = entry_price + 1.5 * risk
            tp2 = entry_price + 3.0 * risk
        else:
            tp1 = entry_price - 1.5 * risk
            tp2 = entry_price - 3.0 * risk
        return tp1, tp2

    def _calc_qty(self, size_usdt: float, entry_price: float, direction: str) -> float:
        """
        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç: 100 USDT / —Ü–µ–Ω–∞.
        –î–ª—è short –ø—Ä–æ—Å—Ç–æ –¥–µ–ª–∞–µ–º qty –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º.
        """
        if entry_price <= 0:
            return 0.0
        qty = size_usdt / entry_price
        if direction == "bear":
            qty = -qty
        return qty

    def _process_position_on_candle(
        self,
        pos: Position,
        high: float,
        low: float,
        t_close_ms: int,
    ):
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —Ü–µ–Ω–∞ –ø—Ä–∏—à–ª–∞ –ø–µ—Ä–≤–æ–π ‚Äî –∫ SL, TP1 –∏–ª–∏ TP2.
        –õ–æ–≥–∏–∫–∞:
        - –≤—Å–µ–≥–¥–∞ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º SL;
        - –∑–∞—Ç–µ–º TP1 (–µ—Å–ª–∏ –µ—â—ë –Ω–µ –±—ã–ª);
        - –∑–∞—Ç–µ–º TP2.
        """
        remaining_qty = pos.remaining_qty()
        if remaining_qty == 0:
            # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
            self._close_position_if_done(pos, t_close_ms)
            return

        if pos.direction == "long":
            self._process_long_position(pos, high, low, t_close_ms)
        else:
            self._process_short_position(pos, high, low, t_close_ms)

    def _process_long_position(
        self,
        pos: Position,
        high: float,
        low: float,
        t_close_ms: int,
    ):
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º SL
        if low <= pos.sl:
            self._close_full_at_price(pos, pos.sl, t_close_ms, reason="SL")
            return

        # 2. TP1 (–µ—Å–ª–∏ –µ—â—ë –Ω–µ –±—ã–ª)
        if not pos.tp1_hit and high >= pos.tp1:
            self._close_half_at_price(pos, pos.tp1, t_close_ms, reason="TP1")
            # –ü–µ—Ä–µ–Ω–æ—Å–∏–º SL –≤ –±–µ–∑—É–±—ã—Ç–æ–∫
            pos.sl = pos.entry_price
            pos.tp1_hit = True

        # 3. TP2 (–µ—Å–ª–∏ –µ—Å—Ç—å –µ—â—ë –æ–±—ä—ë–º)
        remaining_qty = pos.remaining_qty()
        if remaining_qty != 0 and high >= pos.tp2:
            self._close_full_at_price(pos, pos.tp2, t_close_ms, reason="TP2")

    def _process_short_position(
        self,
        pos: Position,
        high: float,
        low: float,
        t_close_ms: int,
    ):
        # 1. SL
        if high >= pos.sl:
            self._close_full_at_price(pos, pos.sl, t_close_ms, reason="SL")
            return

        # 2. TP1
        if not pos.tp1_hit and low <= pos.tp1:
            self._close_half_at_price(pos, pos.tp1, t_close_ms, reason="TP1")
            # –ë–µ–∑—É–±—ã—Ç–æ–∫
            pos.sl = pos.entry_price
            pos.tp1_hit = True

        # 3. TP2
        remaining_qty = pos.remaining_qty()
        if remaining_qty != 0 and low <= pos.tp2:
            self._close_full_at_price(pos, pos.tp2, t_close_ms, reason="TP2")

    def _close_half_at_price(self, pos: Position, price: float, t_close_ms: int, reason: str):
        remaining_qty = pos.remaining_qty()
        if remaining_qty == 0:
            return

        half_qty = remaining_qty / 2.0
        half_size_usdt = pos.remaining_size_usdt() / 2.0

        part = TradePart(
            size_usdt=half_size_usdt,
            qty=half_qty,
            entry_price=pos.entry_price,
            exit_price=price,
            exit_time_ms=t_close_ms,
            reason=reason,
        )
        pos.parts.append(part)

        print(
            f"PAPER PART #{pos.id}: {pos.symbol} {pos.timeframe} {pos.direction} "
            f"{reason} qty={half_qty:.6f} exit={price:.4f} pnl={part.pnl_usdt:.2f}USDT "
            f"({part.pnl_percent:.2f}%)"
        )

        self._close_position_if_done(pos, t_close_ms)

    def _close_full_at_price(self, pos: Position, price: float, t_close_ms: int, reason: str):
        remaining_qty = pos.remaining_qty()
        if remaining_qty == 0:
            return

        remaining_size_usdt = pos.remaining_size_usdt()

        part = TradePart(
            size_usdt=remaining_size_usdt,
            qty=remaining_qty,
            entry_price=pos.entry_price,
            exit_price=price,
            exit_time_ms=t_close_ms,
            reason=reason,
        )
        pos.parts.append(part)

        print(
            f"PAPER CLOSE #{pos.id}: {pos.symbol} {pos.timeframe} {pos.direction} "
            f"{reason} qty={remaining_qty:.6f} exit={price:.4f} pnl={part.pnl_usdt:.2f}USDT "
            f"({part.pnl_percent:.2f}%)"
        )

        self._close_position_if_done(pos, t_close_ms)

    def _close_position_if_done(self, pos: Position, t_close_ms: int):
        # –ï—Å–ª–∏ –µ—â—ë –µ—Å—Ç—å –æ–±—ä—ë–º ‚Äî —Å–¥–µ–ª–∫–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
        if pos.remaining_qty() != 0:
            return

        # –§–∏–∫—Å–∏—Ä—É–µ–º –∑–∞–∫—Ä—ã—Ç–∏–µ
        pos.closed = True
        pos.closed_at_ms = t_close_ms

        # –ò—Ç–æ–≥–æ–≤—ã–π PnL
        total_pnl_usdt = sum(p.pnl_usdt for p in pos.parts)
        total_pnl_percent = (
            total_pnl_usdt / pos.size_usdt * 100.0
            if pos.size_usdt else 0.0
        )

        # --- –§–ª–∞–≥–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π ---
        tp1_hit = any(p.reason == "TP1" for p in pos.parts)
        tp2_hit = any(p.reason == "TP2" for p in pos.parts)
        sl_hit  = any(p.reason == "SL"  for p in pos.parts)

        # --- –ü—Ä–∏—á–∏–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏—è ---
        if tp2_hit:
            close_reason = "TP1+TP2"
        elif tp1_hit and sl_hit:
            close_reason = "TP1+SL"
        elif sl_hit:
            close_reason = "SL-only"
        else:
            close_reason = None

        # --- –§–æ—Ä–º–∏—Ä—É–µ–º CompletedTrade ---
        trade = CompletedTrade(
            id=pos.id,
            symbol=pos.symbol,
            timeframe=pos.timeframe,
            direction=pos.direction,
            setup=pos.setup,
            opened_at_ms=pos.opened_at_ms,
            closed_at_ms=pos.closed_at_ms,

            entry_price=pos.entry_price,
            size_usdt=pos.size_usdt,

            tp1_price=pos.tp1,
            tp2_price=pos.tp2,
            sl_price=pos.sl,

            tp1_hit=tp1_hit,
            tp2_hit=tp2_hit,
            sl_hit=sl_hit,

            close_reason=close_reason,

            pnl_usdt=total_pnl_usdt,
            pnl_percent=total_pnl_percent,

            parts=list(pos.parts),
        )

        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        self.completed_trades.append(trade)

        print(
            f"PAPER DONE #{trade.id}: {trade.symbol} {trade.timeframe} {trade.direction} "
            f"pnl={trade.pnl_usdt:.2f}USDT ({trade.pnl_percent:.2f}%)"
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º JSON
        self.save_trades_to_json()


    # ---------- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è –æ—Ç—á—ë—Ç–Ω–æ—Å—Ç–∏ ----------

    def get_equity(self) -> float:
        """
        –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å = initial + —Å—É–º–º–∞—Ä–Ω—ã–π PnL –ø–æ –∑–∞–∫—Ä—ã—Ç—ã–º —Å–¥–µ–ª–∫–∞–º.
        (–û—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ–º, –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∂–µ).
        """
        total_pnl = sum(t.pnl_usdt for t in self.completed_trades)
        return self.initial_balance_usdt + total_pnl

    def export_to_csv(self, path: str) -> None:
        """
        –≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö —Å–¥–µ–ª–æ–∫ –≤ CSV.
        """
        export_trades_to_csv(self.completed_trades, path)

    def print_stats(self) -> None:
        """
        –ü–µ—á–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —Å–¥–µ–ª–∫–∞–º (–ø–æ –∫–∞–∂–¥–æ–º—É —Å–µ—Ç–∞–ø—É).
        """
        print_stats_for_trades(self.completed_trades)

    def plot_equity_curve(self, setup: str) -> None:
        """
        –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ equity-curve –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —Å–µ—Ç–∞–ø—É.
        """
        plot_equity_curve_for_trades(self.completed_trades, setup, self.initial_balance_usdt)

    def save_trades_to_json(self, path: str = "web/backend/app/data/trades.json") -> None:
        """
        –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—Å–µ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏ –≤ JSON-—Ñ–∞–π–ª,
        —á—Ç–æ–±—ã backend (FastAPI) –º–æ–≥ –∏—Ö —á–∏—Ç–∞—Ç—å.
        """
        import json
        from pathlib import Path

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º CompletedTrade ‚Üí dict
        data = [t.dict() for t in self.completed_trades]

        # –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é, –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
        Path(path).parent.mkdir(parents=True, exist_ok=True)

        # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º JSON
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        print(f"üíæ Trades saved to JSON: {path}")


def make_paper_trading_handler(engine: PaperTradingEngine):
    """
    –ê–¥–∞–ø—Ç–µ—Ä –ø–æ–¥ SignalRouter: handler(signal: Signal).
    """
    def handler(signal: Signal):
        engine.on_signal(signal)
    return handler



================================================================================
FILE: telegram_handler.py
PATH: handlers\telegram_handler.py
================================================================================

# handlers/telegram_handler.py
from models import Signal
from notifier import send_telegram_message
from signal_formatter import format_signal


def make_telegram_handler(tg_token: str, tg_chat_id: str, tz: str):
    def handler(signal: Signal):
        text = format_signal(signal, tz)
        send_telegram_message(tg_token, tg_chat_id, text)
    return handler



================================================================================
FILE: notifier.py
PATH: notifier.py
================================================================================

# notifier.py
import requests

def send_telegram_message(token: str, chat_id: str, text: str) -> None:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤—Å–µ–º–∏ —Å–µ—Ç–∞–ø–∞–º–∏ –∏ –æ—Å–Ω–æ–≤–Ω—ã–º —Ü–∏–∫–ª–æ–º.
    """
    if not token or not chat_id:
        print("‚ö†Ô∏è TELEGRAM_BOT_TOKEN –∏–ª–∏ TELEGRAM_CHAT_ID –ø—É—Å—Ç—ã ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—é –æ—Ç–ø—Ä–∞–≤–∫—É")
        return

    try:
        r = requests.post(
            f"https://api.telegram.org/bot{token}/sendMessage",
            json={
                "chat_id": chat_id,
                "text": text,
                "parse_mode": "HTML",
                "disable_web_page_preview": True,
            },
            timeout=10,
        )
        r.raise_for_status()
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram: {e}")



================================================================================
FILE: setup_manager.py
PATH: setup_manager.py
================================================================================

# setup_manager.py
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Protocol, Iterable

from models import Candle, Signal


class BaseSetup(Protocol):
    """
    –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å–µ—Ç–∞–ø–∞.
    –ö–∞–∂–¥—ã–π —Å–µ—Ç–∞–ø –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∑–∞–∫—Ä—ã—Ç—É—é —Å–≤–µ—á—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0..N —Å–∏–≥–Ω–∞–ª–æ–≤.
    """
    name: str

    def on_candle(self, candle: Candle) -> List[Signal]:
        ...


@dataclass
class SetupManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–≥–æ–Ω—è–µ—Ç —Å–≤–µ—á—É —á–µ—Ä–µ–∑ –≤—Å–µ –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã–µ —Å–µ—Ç–∞–ø—ã
    –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–∏–≥–Ω–∞–ª–æ–≤.
    """
    setups: Iterable[BaseSetup]

    def process_candle(self, candle: Candle) -> List[Signal]:
        signals: List[Signal] = []
        for setup in self.setups:
            try:
                setup_signals = setup.on_candle(candle)
                if setup_signals:
                    signals.extend(setup_signals)
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Å–µ—Ç–∞–ø–µ {getattr(setup, 'name', setup)}: {e}")
        return signals



================================================================================
FILE: __init__.py
PATH: setups\__init__.py
================================================================================

#__init__.py
from .falling_star import FallingStarSetup
from .hammer import HammerSetup
from .max_volume_zone import MaxVolumeZoneSetup
from .rsi_zone import RSIZoneSetup

__all__ = [
    "FallingStarSetup",
    "HammerSetup",
    "MaxVolumeZoneSetup",
    "RSIZoneSetup",
]



================================================================================
FILE: falling_star.py
PATH: setups\falling_star.py
================================================================================

# setups/falling_star.py
from models import Candle, Signal

def is_falling_star(o: float, h: float, l: float, c: float) -> bool:
    """
    –£–ø—Ä–æ—â—ë–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ Falling Star:
      - —Ç–µ–ª–æ –º–∞–ª–æ: |o - c| <= 0.3 * (h - l)
      - –≤–µ—Ä—Ö–Ω—è—è —Ç–µ–Ω—å –±–æ–ª—å—à–∞—è: (h - max(o, c)) >= 0.6 * (h - l)
      - –Ω–∏–∂–Ω—è—è —Ç–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∞—è: (min(o, c) - l) <= 0.15 * (h - l)
    """
    range_high_low = max(h - l, 1e-12)
    body_size = abs(o - c)
    upper_shadow = h - max(o, c)
    lower_shadow = min(o, c) - l
    return (
        body_size <= 0.3 * range_high_low
        and upper_shadow >= 0.6 * range_high_low
        and lower_shadow <= 0.15 * range_high_low
    )

class FallingStarSetup:
    """
    –ê–¥–∞–ø—Ç–µ—Ä –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —Å–µ—Ç–∞–ø–æ–≤.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç is_falling_star, –Ω–æ –Ω–µ —à–ª—ë—Ç Telegram ‚Äî —Ç–æ–ª—å–∫–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Signal.
    """
    name = "FallingStar"

    def on_candle(self, candle: Candle) -> list[Signal]:
        if is_falling_star(candle.o, candle.h, candle.l, candle.c):
            return [
                Signal(
                    symbol=candle.symbol,
                    timeframe=candle.timeframe,
                    t_close_ms=candle.t_close_ms,
                    setup=self.name,
                    direction="bear",   # –ø–∞–¥–∞—é—â–∞—è –∑–≤–µ–∑–¥–∞ ‚Äî –º–µ–¥–≤–µ–∂–∏–π —Å–∏–≥–Ω–∞–ª
                    extra={},
                )
            ]
        return []



================================================================================
FILE: hammer.py
PATH: setups\hammer.py
================================================================================

# setups/hammer.py
def is_hammer(o: float, h: float, l: float, c: float) -> bool:
    """
    –ó–µ—Ä–∫–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ Falling Star:
    - –º–∞–ª–µ–Ω—å–∫–æ–µ —Ç–µ–ª–æ
    - –¥–ª–∏–Ω–Ω–∞—è –Ω–∏–∂–Ω—è—è —Ç–µ–Ω—å
    - –∫–æ—Ä–æ—Ç–∫–∞—è –≤–µ—Ä—Ö–Ω—è—è —Ç–µ–Ω—å
    """
    range_hl = max(h - l, 1e-12)
    body = abs(o - c)
    upper_shadow = h - max(o, c)
    lower_shadow = min(o, c) - l

    return (
        body <= 0.3 * range_hl and
        lower_shadow >= 0.6 * range_hl and
        upper_shadow <= 0.15 * range_hl
    )

from models import Candle, Signal

class HammerSetup:
    """
    –ê–¥–∞–ø—Ç–µ—Ä –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ —Å–µ—Ç–∞–ø–æ–≤.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç is_hammer, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Signal –±–µ–∑ Telegram.
    """
    name = "Hammer"

    def on_candle(self, candle: Candle) -> list[Signal]:
        if is_hammer(candle.o, candle.h, candle.l, candle.c):
            return [
                Signal(
                    symbol=candle.symbol,
                    timeframe=candle.timeframe,
                    t_close_ms=candle.t_close_ms,
                    setup=self.name,
                    direction="bull",  # –º–æ–ª–æ—Ç ‚Äî –±—ã—á–∏–π —Å–∏–≥–Ω–∞–ª
                    extra={},
                )
            ]
        return []



================================================================================
FILE: max_volume_zone.py
PATH: setups\max_volume_zone.py
================================================================================

# setups/max_volume_zone.py
from datetime import datetime
from zoneinfo import ZoneInfo
from utils.timeframes import tf_seconds
from models import Candle, Signal

class MaxVolumeZoneSetup:
    """
    –ê–¥–∞–ø—Ç–µ—Ä –¥–ª—è Max_Volume_Zone –ø–æ–¥ –º–µ–Ω–µ–¥–∂–µ—Ä —Å–µ—Ç–∞–ø–æ–≤.
    –ë–µ—Ä—ë—Ç exchange –∏ cfg –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∏ –Ω–∞ –∫–∞–∂–¥–æ–π —Å–≤–µ—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Signal.
    """
    name = "MaxVolumeZone"

    def __init__(self, exchange, cfg):
        self.exchange = exchange
        self.cfg = cfg

    def on_candle(self, candle: Candle) -> list[Signal]:
        exchange = self.exchange
        cfg = self.cfg

        symbol = candle.symbol
        timeframe = candle.timeframe
        candle_high = candle.h
        candle_low = candle.l
        candle_close_ts_ms = candle.t_close_ms

        timeframe_sec = tf_seconds(exchange, timeframe)
        if timeframe_sec <= 0:
            return []

        candle_open_ts_ms = candle_close_ts_ms - timeframe_sec * 1000

        tz = ZoneInfo(cfg.tz)
        dt_open = datetime.fromtimestamp(candle_open_ts_ms / 1000, tz)
        dt_close = datetime.fromtimestamp(candle_close_ts_ms / 1000, tz)

        open_str = dt_open.strftime("%Y-%m-%d %H:%M")
        close_str = dt_close.strftime("%Y-%m-%d %H:%M")

        price_range = candle_high - candle_low
        if price_range <= 0:
            return []

        price_step = price_range / 5.0
        timeframe_minutes = timeframe_sec // 60
        minutes_limit = timeframe_minutes + 5

        try:
            raw_minutes = exchange.fetch_ohlcv(
                symbol,
                timeframe="1m",
                since=candle_open_ts_ms,
                limit=minutes_limit,
            )
        except Exception as e:
            print(f"‚ùå {symbol} {timeframe}: –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è 1m ‚Äî {e}")
            return []

        if not raw_minutes:
            return []

        zone_volumes = [0.0] * 5

        for row in raw_minutes:
            if len(row) < 6:
                continue

            minute_open_ts_ms, o, h, l, c, vol = row[:6]

            if not (candle_open_ts_ms <= minute_open_ts_ms < candle_close_ts_ms):
                continue

            minute_high = float(h)
            minute_low = float(l)
            mid_price = (minute_high + minute_low) / 2.0

            distance_from_low = mid_price - candle_low
            if distance_from_low < 0 or distance_from_low > price_range:
                continue

            zone_index_from_bottom = int(distance_from_low // price_step)
            if zone_index_from_bottom >= 5:
                zone_index_from_bottom = 4

            zone_index_from_top = 4 - zone_index_from_bottom
            zone_volumes[zone_index_from_top] += float(vol)

        max_volume = max(zone_volumes)
        if max_volume <= 0:
            return []

        max_zone_index = zone_volumes.index(max_volume)
        max_zone_number = max_zone_index + 1

        if max_zone_number == 1:
            direction = "bear"
        elif max_zone_number == 5:
            direction = "bull"
        else:
            return []

        return [
            Signal(
                symbol=symbol,
                timeframe=timeframe,
                t_close_ms=candle_close_ts_ms,
                setup=self.name,
                direction=direction,
                extra={
                    "open_str": open_str,
                    "close_str": close_str,
                    "max_zone_number": max_zone_number,
                },
            )
        ]



================================================================================
FILE: rsi_zone.py
PATH: setups\rsi_zone.py
================================================================================

# setups/rsi_zone.py
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import List
from utils.timeframes import tf_seconds
from models import Candle, Signal


def compute_rsi(closes: List[float], period: int = 14) -> float | None:
    """
    –†–∞—Å—á—ë—Ç RSI –ø–æ —Ñ–æ—Ä–º—É–ª–µ Wilder (RSI-14).
    """
    if len(closes) < period + 1:
        return None

    gains = []
    losses = []

    for i in range(1, period + 1):
        diff = closes[-i] - closes[-i - 1]
        if diff >= 0:
            gains.append(diff)
            losses.append(0.0)
        else:
            gains.append(0.0)
            losses.append(-diff)

    avg_gain = sum(gains) / period
    avg_loss = sum(losses) / period

    if avg_loss == 0:
        return 100.0

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

class RSIZoneSetup:
    """
    –ê–¥–∞–ø—Ç–µ—Ä RSI Zone Entry.
    –†–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ compute_rsi –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Signal.
    """
    name = "RSI"

    def __init__(self, exchange, cfg, period: int = 14):
        self.exchange = exchange
        self.cfg = cfg
        self.period = period

    def on_candle(self, candle: Candle) -> list[Signal]:
        exchange = self.exchange
        cfg = self.cfg
        symbol = candle.symbol
        timeframe = candle.timeframe
        candle_close_ts_ms = candle.t_close_ms

        try:
            raw = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=100)
        except Exception as e:
            print(f"‚ùå {symbol} {timeframe}: –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è OHLCV –¥–ª—è RSI ‚Äî {e}")
            return []

        if not raw or len(raw) < 15:
            return []

        timeframe_sec = tf_seconds(exchange, timeframe)

        closed_records = []
        for row in raw:
            t_open_ms, o, h, l, c, *_ = row
            t_close_ms = int(t_open_ms) + timeframe_sec * 1000
            if t_close_ms <= candle_close_ts_ms:
                closed_records.append((t_close_ms, o, h, l, c))

        if len(closed_records) < 15:
            return []

        closed_records.sort(key=lambda x: x[0])

        if closed_records[-1][0] != candle_close_ts_ms:
            return []

        closes = [c[4] for c in closed_records]
        rsi = compute_rsi(closes, period=self.period)
        if rsi is None:
            return []

        candle_open_ts_ms = candle_close_ts_ms - timeframe_sec * 1000
        tz = ZoneInfo(cfg.tz)
        open_str = datetime.fromtimestamp(candle_open_ts_ms / 1000, tz).strftime("%Y-%m-%d %H:%M")
        close_str = datetime.fromtimestamp(candle_close_ts_ms / 1000, tz).strftime("%Y-%m-%d %H:%M")

        if rsi <= 20:
            direction = "oversold"
        elif rsi >= 80:
            direction = "overbought"
        else:
            return []

        return [
            Signal(
                symbol=symbol,
                timeframe=timeframe,
                t_close_ms=candle_close_ts_ms,
                setup=self.name,
                direction=direction,
                extra={
                    "rsi": rsi,
                    "open_str": open_str,
                    "close_str": close_str,
                },
            )
        ]



================================================================================
FILE: signal_formatter.py
PATH: signal_formatter.py
================================================================================

# signal_formatter.py
from datetime import datetime
from zoneinfo import ZoneInfo

from models import Signal


def format_signal(signal: Signal, tz: str) -> str:
    """
    –§–æ—Ä–º–∏—Ä—É–µ—Ç –∫—Ä–∞—Å–∏–≤–æ–µ Telegram‚Äë—Å–æ–æ–±—â–µ–Ω–∏–µ.
    """

    # –ò–∫–æ–Ω–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    if signal.direction in ("bull", "oversold"):
        icon = "üü¢"
    elif signal.direction in ("bear", "overbought"):
        icon = "üî¥"
    else:
        icon = "‚ö™"

    # –í—Ä–µ–º—è –∑–∞–∫—Ä—ã—Ç–∏—è —Å–≤–µ—á–∏
    dt_close = datetime.fromtimestamp(signal.t_close_ms / 1000, ZoneInfo(tz))
    candle_close_str = dt_close.strftime("%H:%M")

    # –í—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–≤–µ—á–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ extra)
    open_str = signal.extra.get("open_str")
    close_str = signal.extra.get("close_str")

    if open_str and close_str:
        candle_range = f"{open_str.split(' ')[1]}‚Äì{close_str.split(' ')[1]}"
    else:
        # fallback: –ø—Ä–æ—Å—Ç–æ –≤—Ä–µ–º—è –∑–∞–∫—Ä—ã—Ç–∏—è
        candle_range = candle_close_str

    # –í—Ä–µ–º—è —Å–∏–≥–Ω–∞–ª–∞
    now = datetime.now(ZoneInfo(tz))
    signal_time = now.strftime("%H:%M %d.%m.%Y")

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç
    text = (
        f"<b>{icon} {signal.setup}</b>\n"
        f"<b>–¢–∞–π–º—Ñ—Ä–µ–π–º:</b> {signal.timeframe}\n"
        f"<b>–ü–∞—Ä–∞:</b> {signal.symbol}\n"
        f"<b>–°–≤–µ—á–∞:</b> {candle_range}\n"
        f"<b>–°–∏–≥–Ω–∞–ª:</b> {signal_time}"
    )

    return text



================================================================================
FILE: signal_router.py
PATH: signal_router.py
================================================================================

# signal_router.py
from dataclasses import dataclass
from typing import Callable, List

from models import Signal
from notifier import send_telegram_message


@dataclass
class SignalRouter:
    """
    –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ç–æ—Ä —Å–∏–≥–Ω–∞–ª–æ–≤.
    –ö–∞–∂–¥—ã–π —Å–∏–≥–Ω–∞–ª –ø—Ä–æ—Ö–æ–¥–∏—Ç —á–µ—Ä–µ–∑ –≤—Å–µ –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏.
    """
    handlers: List[Callable[[Signal], None]]

    def route(self, signal: Signal) -> None:
        for handler in self.handlers:
            try:
                handler(signal)
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ —Å–∏–≥–Ω–∞–ª–æ–≤: {e}")



================================================================================
FILE: test_save.py
PATH: test_save.py
================================================================================

from handlers.paper_trading import PaperTradingEngine

engine = PaperTradingEngine(exchange=None)
engine.completed_trades = []  # –∏–ª–∏ –ø–æ–¥—Å—Ç–∞–≤—å —Ä–µ–∞–ª—å–Ω—ã–µ —Å–¥–µ–ª–∫–∏
engine.save_trades_to_json()



================================================================================
FILE: test_setup_manager.py
PATH: test_setup_manager.py
================================================================================

from models import Candle
from setup_manager import SetupManager
from setups import FallingStarSetup, HammerSetup, MaxVolumeZoneSetup, RSIZoneSetup
from falling_star_daemon import load_config, make_exchange


def main():
    cfg = load_config()
    exchange = make_exchange(cfg.exchange_id)

    setup_manager = SetupManager(
        setups=[
            FallingStarSetup(),
            HammerSetup(),
            MaxVolumeZoneSetup(exchange, cfg),
            RSIZoneSetup(exchange, cfg),
        ]
    )

    # —Ç–µ—Å—Ç–æ–≤–∞—è —Å–≤–µ—á–∞
    candle = Candle(
        symbol="BTC/USDT",
        timeframe="5m",
        t_close_ms=1700000000000,
        o=50000,
        h=50500,
        l=49500,
        c=49900,
    )

    signals = setup_manager.process_candle(candle)

    print("\n=== –†–ï–ó–£–õ–¨–¢–ê–¢–´ –¢–ï–°–¢–ê ===")
    for sig in signals:
        print(sig)


if __name__ == "__main__":
    main()



================================================================================
FILE: __init__.py
PATH: utils\__init__.py
================================================================================




================================================================================
FILE: timeframes.py
PATH: utils\timeframes.py
================================================================================

# utils/timeframes.py
import ccxt


def tf_seconds(exchange: ccxt.Exchange, timeframe: str) -> int:
    """
    –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞ –≤ —Å–µ–∫—É–Ω–¥—ã.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–µ–º–æ–Ω–æ–º –∏ —Å–µ—Ç–∞–ø–∞–º–∏.
    """
    return exchange.parse_timeframe(timeframe)


